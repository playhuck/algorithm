import com.sun.source.tree.Tree;
import stack_queue.Stack144_BinaryTreePreorderTraversal;

import javax.swing.tree.TreeNode;
import java.math.BigInteger;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class Solution {

    public static void main(String[] args) {

//        System.out.println(countGoodRectangles(
//                new int[][]{{5,8},{3,9},{5,12},{16,5}}
//        ));
//        System.out.println(new RecentCounter().ping(
//                new String[]{"RecentCounter", "ping", "ping", "ping", "ping"}
//        ));
//        System.out.println(simplifyPath(
//                "/home/../../.."
//        ));
//        System.out.println(minNumber(
//                new String[]{"hello","world","leetcode"}, "welldonehoneyr"
//        ));
//        System.out.println(countStudents(
//                new int[]{1,1,1,0,0,1}, new int[]{1,0,0,0,1,1}
//        ));
//        System.out.println(timeRequiredToBuy(
//                new int[]{5,1,1,1}, 0
//        ));
//        System.out.println(kWeakestRows(
//                new int[]{10,3,8,9,4}
//        ));
    }

    /*
        정수 배열 nums와 정수 limit가 주어질 때,
        이 하위 배열의 모든 두 원소 간의 절대 차이가 limit 이하인 가장 긴 비어있지 않은 하위 배열의 크기를 반환하세요.
         [8,2,4,7], limit = 4
     */

    public static int longestSubarray(int[] nums, int limit) {

        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());

        return 1;
    }

}